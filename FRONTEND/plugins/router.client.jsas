// FRONTEND/plugins/router.client.js
export default defineNuxtPlugin((nuxtApp) => {
  const router = useRouter()
  const { isAuthenticated, user } = useAuth()

  console.log('üöÄ Inicializando configuraci√≥n del router...')

  // Configurar manejo global de errores de navegaci√≥n
  router.onError((error, to, from) => {
    console.error('üö® Error de navegaci√≥n:', {
      error: error.message,
      from: from?.fullPath,
      to: to?.fullPath,
      stack: error.stack
    })

    // Manejar errores espec√≠ficos
    if (error.message.includes('404') || error.message.includes('not found')) {
      console.log('üîç Redirigiendo por p√°gina no encontrada')
      return handleNotFoundError(to, from)
    }

    if (error.message.includes('403') || error.message.includes('forbidden')) {
      console.log('üö´ Redirigiendo por acceso prohibido')
      return handleForbiddenError(to, from)
    }

    if (error.message.includes('500') || error.message.includes('server')) {
      console.log('üí• Error del servidor')
      return handleServerError(error)
    }

    // Error gen√©rico
    console.log('‚ùì Error de navegaci√≥n gen√©rico')
    throw createError({
      statusCode: 500,
      statusMessage: 'Error de navegaci√≥n',
      data: { 
        originalError: error.message,
        from: from?.fullPath,
        to: to?.fullPath
      }
    })
  })

  // Interceptar antes de cada navegaci√≥n
  router.beforeEach(async (to, from) => {
    console.log('üß≠ Navegaci√≥n interceptada:', {
      from: from.fullPath,
      to: to.fullPath,
      authenticated: isAuthenticated.value,
      userType: user.value?.tipoUsuario
    })

    // Limpiar estado previo
    await clearPreviousState()

    // Validar rutas protegidas
    const navigationResult = await validateProtectedRoute(to, from)
    if (navigationResult !== true) {
      return navigationResult
    }

    // Validar permisos por rol
    const roleResult = await validateRolePermissions(to, from)
    if (roleResult !== true) {
      return roleResult
    }

    // Log de navegaci√≥n exitosa
    console.log('‚úÖ Navegaci√≥n permitida')
    return true
  })

  // Interceptar despu√©s de cada navegaci√≥n exitosa
  router.afterEach((to, from, failure) => {
    if (failure) {
      console.error('‚ùå Navegaci√≥n fall√≥:', failure)
      return
    }

    console.log('üèÅ Navegaci√≥n completada:', {
      from: from?.fullPath,
      to: to.fullPath,
      timestamp: new Date().toISOString()
    })

    // Actualizar estado de la aplicaci√≥n
    updateApplicationState(to)

    // Limpiar notificaciones anteriores
    clearNotifications()

    // Scroll al top para nuevas p√°ginas
    if (to.path !== from?.path) {
      nextTick(() => {
        window.scrollTo({ top: 0, behavior: 'smooth' })
      })
    }
  })

  // ===== FUNCIONES AUXILIARES =====

  /**
   * Manejar error 404
   */
  const handleNotFoundError = (to, from) => {
    console.log('üìç Manejando error 404 para:', to.fullPath)

    if (isAuthenticated.value) {
      // Redirigir al dashboard apropiado seg√∫n el tipo de usuario
      const dashboards = {
        'Cliente': '/empeno',
        'Evaluador': '/evaluador',
        'Administrador': '/admin',
        'Cobrador': '/collector',
        'Personal': '/personal'
      }

      const dashboard = dashboards[user.value?.tipoUsuario] || '/empeno'
      console.log('üè† Redirigiendo a dashboard:', dashboard)
      
      return navigateTo(dashboard, { replace: true })
    } else {
      console.log('üè† Redirigiendo a inicio')
      return navigateTo('/', { replace: true })
    }
  }

  /**
   * Manejar error 403
   */
  const handleForbiddenError = (to, from) => {
    console.log('üö´ Manejando error de acceso prohibido')
    
    if (isAuthenticated.value) {
      // Redirigir al dashboard del usuario
      const dashboards = {
        'Cliente': '/empeno',
        'Evaluador': '/evaluador', 
        'Administrador': '/admin',
        'Cobrador': '/cobranza',
        'Personal': '/personal'
      }

      const dashboard = dashboards[user.value?.tipoUsuario] || '/empeno'
      
      // Mostrar mensaje de error
      if (process.client) {
        setTimeout(() => {
          showNotification('No tienes permisos para acceder a esta p√°gina', 'error')
        }, 500)
      }

      return navigateTo(dashboard, { replace: true })
    } else {
      return navigateTo('/auth/login', { 
        query: { redirect: to.fullPath },
        replace: true 
      })
    }
  }

  /**
   * Manejar error del servidor
   */
  const handleServerError = (error) => {
    console.error('üí• Error del servidor:', error)
    
    throw createError({
      statusCode: 500,
      statusMessage: 'Error interno del servidor',
      data: {
        message: 'Ocurri√≥ un error interno. Por favor, intenta nuevamente.',
        canRetry: true
      }
    })
  }

  /**
   * Limpiar estado previo
   */
  const clearPreviousState = async () => {
    // Limpiar notificaciones
    if (process.client) {
      const notifications = document.querySelectorAll('.notification')
      notifications.forEach(notification => {
        notification.remove()
      })
    }
  }

  /**
   * Validar rutas protegidas
   */
  const validateProtectedRoute = async (to, from) => {
    // Rutas que requieren autenticaci√≥n
    const protectedRoutes = [
      '/empeno',
      '/evaluador',
      '/admin', 
      '/cobranza',
      '/personal',
      '/profile'
    ]

    const requiresAuth = protectedRoutes.some(route => to.path.startsWith(route))

    if (requiresAuth && !isAuthenticated.value) {
      console.log('üîí Ruta protegida sin autenticaci√≥n')
      
      return navigateTo('/auth/login', {
        query: { redirect: to.fullPath },
        replace: true
      })
    }

    // Rutas solo para invitados
    const guestOnlyRoutes = ['/auth/login', '/auth/register']
    const isGuestOnly = guestOnlyRoutes.some(route => to.path.startsWith(route))

    if (isGuestOnly && isAuthenticated.value) {
      console.log('üë§ Usuario autenticado en ruta de invitado')
      
      // Redirigir al dashboard apropiado
      const dashboards = {
        'Cliente': '/empeno',
        'Evaluador': '/evaluador',
        'Administrador': '/admin',
        'Cobrador': '/cobranza',
        'Personal': '/personal'
      }

      const dashboard = dashboards[user.value?.tipoUsuario] || '/empeno'
      return navigateTo(dashboard, { replace: true })
    }

    return true
  }

  /**
   * Validar permisos por rol
   */
  const validateRolePermissions = async (to, from) => {
    if (!isAuthenticated.value) {
      return true // Ya se maneja en validateProtectedRoute
    }

    const userType = user.value?.tipoUsuario

    // Definir reglas de acceso por tipo de usuario
    const accessRules = {
      'Cliente': {
        allowed: ['/empeno', '/profile', '/'],
        default: '/empeno'
      },
      'Evaluador': {
        allowed: ['/evaluador', '/profile', '/'],
        default: '/evaluador'
      },
      'Administrador': {
        allowed: ['/admin', '/evaluador', '/empeno', '/cobranza', '/personal', '/profile', '/'],
        default: '/admin'
      },
      'Cobrador': {
        allowed: ['/cobranza', '/profile', '/'],
        default: '/cobranza'
      },
      'Personal': {
        allowed: ['/personal', '/profile', '/'],
        default: '/personal'
      }
    }

    const userRules = accessRules[userType]
    
    if (!userRules) {
      console.log('‚ùì Tipo de usuario desconocido:', userType)
      return navigateTo('/auth/login', { replace: true })
    }

    // Verificar si la ruta est√° permitida
    const hasAccess = userRules.allowed.some(allowedPath => {
      return to.path === allowedPath || to.path.startsWith(allowedPath + '/')
    })

    if (!hasAccess) {
      console.log(`üö´ Usuario ${userType} sin acceso a ${to.path}`)
      
      // Mostrar mensaje de error
      if (process.client) {
        setTimeout(() => {
          showNotification('No tienes permisos para acceder a esta secci√≥n', 'error')
        }, 500)
      }

      return navigateTo(userRules.default, { replace: true })
    }

    return true
  }

  /**
   * Actualizar estado de la aplicaci√≥n
   */
  const updateApplicationState = (to) => {
    // Actualizar t√≠tulo de la p√°gina
    if (process.client) {
      nextTick(() => {
        const titles = {
          '/empeno': 'Mis Pr√©stamos',
          '/evaluador': 'Panel de Evaluador',
          '/admin': 'Panel de Administraci√≥n',
          '/cobranza': 'Panel de Cobranza',
          '/personal': 'Panel de Personal',
          '/profile': 'Mi Perfil',
          '/auth/login': 'Iniciar Sesi√≥n',
          '/auth/register': 'Registrarse'
        }

        let pageTitle = titles[to.path]
        
        if (!pageTitle) {
          // Generar t√≠tulo basado en la ruta
          const pathParts = to.path.split('/').filter(Boolean)
          pageTitle = pathParts.map(part => 
            part.charAt(0).toUpperCase() + part.slice(1)
          ).join(' - ')
        }

        if (pageTitle) {
          document.title = `${pageTitle} - Fredy Fasbear Pr√©stamos`
        }
      })
    }

    // Actualizar meta tags si es necesario
    if (to.meta) {
      // L√≥gica para actualizar meta tags din√°micamente
    }
  }

  /**
   * Limpiar notificaciones
   */
  const clearNotifications = () => {
    if (process.client) {
      // Limpiar notificaciones despu√©s de un delay
      setTimeout(() => {
        const notifications = document.querySelectorAll('.notification.auto-hide')
        notifications.forEach(notification => {
          notification.style.opacity = '0'
          setTimeout(() => notification.remove(), 300)
        })
      }, 100)
    }
  }

  /**
   * Mostrar notificaci√≥n
   */
  const showNotification = (message, type = 'info') => {
    if (!process.client) return

    // Crear elemento de notificaci√≥n
    const notification = document.createElement('div')
    notification.className = `notification notification-${type} auto-hide`
    notification.style.cssText = `
      position: fixed;
      top: 2rem;
      right: 2rem;
      z-index: 10000;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    `

    // Colores por tipo
    const colors = {
      success: '#2ECC71',
      error: '#C0392B',
      warning: '#E67E22',
      info: '#3498DB'
    }

    notification.style.backgroundColor = colors[type] || colors.info
    notification.textContent = message

    // Agregar al DOM
    document.body.appendChild(notification)

    // Animar entrada
    requestAnimationFrame(() => {
      notification.style.opacity = '1'
      notification.style.transform = 'translateX(0)'
    })

    // Auto-remove despu√©s de 5 segundos
    setTimeout(() => {
      notification.style.opacity = '0'
      notification.style.transform = 'translateX(100%)'
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification)
        }
      }, 300)
    }, 5000)
  }

  // Configurar manejo de errores no capturados
  if (process.client) {
    window.addEventListener('unhandledrejection', (event) => {
      console.error('üö® Promise rejection no manejada:', event.reason)
      
      // Si es un error de navegaci√≥n, manejarlo gracefully
      if (event.reason?.message?.includes('navigation')) {
        event.preventDefault()
        console.log('üîß Manejando error de navegaci√≥n no capturado')
        
        // Redirigir a una p√°gina segura
        if (isAuthenticated.value) {
          const dashboards = {
            'Cliente': '/empeno',
            'Evaluador': '/evaluador',
            'Administrador': '/admin',
            'Cobrador': '/cobranza',
            'Personal': '/personal'
          }
          const dashboard = dashboards[user.value?.tipoUsuario] || '/empeno'
          router.push(dashboard)
        } else {
          router.push('/')
        }
      }
    })

    window.addEventListener('error', (event) => {
      console.error('üö® Error global no manejado:', event.error)
    })
  }

  console.log('‚úÖ Configuraci√≥n del router completada')

  // Exponer utilidades globalmente para debugging en desarrollo
  if (process.env.NODE_ENV === 'development' && process.client) {
    window.__routerUtils = {
      showNotification,
      clearNotifications,
      validateRolePermissions,
      isAuthenticated: () => isAuthenticated.value,
      user: () => user.value
    }
    console.log('üõ†Ô∏è Router utils disponibles en window.__routerUtils')
  }
})